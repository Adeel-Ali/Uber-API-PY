# -*- coding: utf-8 -*-

"""
    uberapilib.controllers.api_controller

    This file was automatically generated by APIMATIC BETA v2.0 on 07/19/2016
"""

from uberapilib.controllers.base_controller import *

from uberapilib.models.product_collection import ProductCollection
from uberapilib.models.price_estimate_collection import PriceEstimateCollection
from uberapilib.models.time_estimate_collection import TimeEstimateCollection
from uberapilib.models.user_activity import UserActivity
from uberapilib.models.user_profile import UserProfile
from uberapilib.models.product import Product
from uberapilib.models.promotions_response import PromotionsResponse
from uberapilib.models.request import Request
from uberapilib.models.request_details_collections import RequestDetailsCollections
from uberapilib.models.request_map_response import RequestMapResponse


class APIController(BaseController):

    """A Controller to access Endpoints in the uberapilib API."""

    def __init__(self, http_client = None, http_call_back = None):
        """Constructor which allows a different HTTP client for this controller."""
        BaseController.__init__(self, http_client, http_call_back)

    def get_products_types(self,
                           options=dict()):
        """Does a GET request to /v1/products.

        The Products endpoint returns information about the Uber products
        offered at a given location. The response includes the display name
        and other details about each product, and lists the products in the
        proper display order.

        Args:
            options (dict, optional): Key-value pairs for any of the
                parameters to this API Endpoint. All parameters to the
                endpoint are supplied through the dictionary with their names
                being the key and their desired values being the value. A list
                of parameters that can be used are::

                    latitude -- float -- Latitude component of location.
                    longitude -- float -- Longitude component of location.

        Returns:
            ProductCollection: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Validate required parameters
        if options.get("latitude") == None:
            raise ValueError("Required parameter 'latitude' cannot be None.")
        elif options.get("longitude") == None:
            raise ValueError("Required parameter 'longitude' cannot be None.")

        # The base uri for api requests
        _query_builder = Configuration.BASE_URI
 
        # Prepare query string for API call
        _query_builder += "/v1/products"

        # Process optional query parameters
        _query_parameters = {
            "latitude": options.get('latitude', None),
            "longitude": options.get('longitude', None)
        }
        
        # Validate and preprocess url
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            "user-agent": "APIMATIC 2.0",
            "accept": "application/json",
            "Authorization": "Bearer " + Configuration.o_auth_access_token
        }

        # Prepare the API call.
        _http_request = self.http_client.get(_query_url, headers=_headers, query_parameters=_query_parameters)

        # Invoke the on before request HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_before_request(_http_request)

        # Invoke the API call  to fetch the response.
        _response = self.http_client.execute_as_string(_http_request)

        # Invoke the on after response HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_after_response(_response)

        # Endpoint error handling using HTTP status codes.
        if _response.status_code == 404:
            return None
        elif _response.status_code == 400:
            raise APIException("Malformed request.", 400, _response.raw_body)
        elif _response.status_code == 401:
            raise APIException("Unauthorized the request requires user authentication (not logged in).", 401, _response.raw_body)
        elif _response.status_code == 403:
            raise APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", 403, _response.raw_body)
        elif _response.status_code == 406:
            raise APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", 406, _response.raw_body)
        elif _response.status_code == 422:
            raise APIException("Invalid request. The request body is parse-able however with invalid content.", 422, _response.raw_body)
        elif _response.status_code == 429:
            raise APIException("Too Many Requests. Rate limited.", 429, _response.raw_body)
        elif _response.status_code == 500:
            raise APIException("Internal Server Error.", 500, _response.raw_body)

        # Global error handling using HTTP status codes.
        self.validate_response(_response)    

        # Return appropriate type
        return APIHelper.json_deserialize(_response.raw_body, ProductCollection.from_dictionary)



    def get_price_estimates(self,
                            options=dict()):
        """Does a GET request to /v1/estimates/price.

        The Price Estimates endpoint returns an estimated price range for each
        product offered at a given location. The price estimate is provided as
        a formatted string with the full price range and the localized
        currency symbol.

        Args:
            options (dict, optional): Key-value pairs for any of the
                parameters to this API Endpoint. All parameters to the
                endpoint are supplied through the dictionary with their names
                being the key and their desired values being the value. A list
                of parameters that can be used are::

                    end_latitude -- float -- Latitude component of end
                        location.
                    end_longitude -- float -- Longitude component of end
                        location.
                    start_latitude -- float -- Latitude component of start
                        location.
                    start_longitude -- float -- Longitude component of start
                        location.

        Returns:
            PriceEstimateCollection: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Validate required parameters
        if options.get("end_latitude") == None:
            raise ValueError("Required parameter 'end_latitude' cannot be None.")
        elif options.get("end_longitude") == None:
            raise ValueError("Required parameter 'end_longitude' cannot be None.")
        elif options.get("start_latitude") == None:
            raise ValueError("Required parameter 'start_latitude' cannot be None.")
        elif options.get("start_longitude") == None:
            raise ValueError("Required parameter 'start_longitude' cannot be None.")

        # The base uri for api requests
        _query_builder = Configuration.BASE_URI
 
        # Prepare query string for API call
        _query_builder += "/v1/estimates/price"

        # Process optional query parameters
        _query_parameters = {
            "end_latitude": options.get('end_latitude', None),
            "end_longitude": options.get('end_longitude', None),
            "start_latitude": options.get('start_latitude', None),
            "start_longitude": options.get('start_longitude', None)
        }
        
        # Validate and preprocess url
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            "user-agent": "APIMATIC 2.0",
            "accept": "application/json",
            "Authorization": "Bearer " + Configuration.o_auth_access_token
        }

        # Prepare the API call.
        _http_request = self.http_client.get(_query_url, headers=_headers, query_parameters=_query_parameters)

        # Invoke the on before request HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_before_request(_http_request)

        # Invoke the API call  to fetch the response.
        _response = self.http_client.execute_as_string(_http_request)

        # Invoke the on after response HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_after_response(_response)

        # Endpoint error handling using HTTP status codes.
        if _response.status_code == 404:
            return None
        elif _response.status_code == 400:
            raise APIException("Malformed request.", 400, _response.raw_body)
        elif _response.status_code == 401:
            raise APIException("Unauthorized the request requires user authentication (not logged in).", 401, _response.raw_body)
        elif _response.status_code == 403:
            raise APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", 403, _response.raw_body)
        elif _response.status_code == 406:
            raise APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", 406, _response.raw_body)
        elif _response.status_code == 422:
            raise APIException("Invalid request. The request body is parse-able however with invalid content.", 422, _response.raw_body)
        elif _response.status_code == 429:
            raise APIException("Too Many Requests. Rate limited.", 429, _response.raw_body)
        elif _response.status_code == 500:
            raise APIException("Internal Server Error.", 500, _response.raw_body)

        # Global error handling using HTTP status codes.
        self.validate_response(_response)    

        # Return appropriate type
        return APIHelper.json_deserialize(_response.raw_body, PriceEstimateCollection.from_dictionary)



    def get_time_estimates(self,
                           options=dict()):
        """Does a GET request to /v1/estimates/time.

        The Time Estimates endpoint returns ETAs for all products offered at a
        given location, with the responses expressed as integers in seconds.
        We recommend that this endpoint be called every minute to provide the
        most accurate, up-to-date ETAs.

        Args:
            options (dict, optional): Key-value pairs for any of the
                parameters to this API Endpoint. All parameters to the
                endpoint are supplied through the dictionary with their names
                being the key and their desired values being the value. A list
                of parameters that can be used are::

                    start_latitude -- float -- Latitude component of the start
                        location
                    start_longitude -- float -- Longitude component of the
                        start location
                    customer_uuid -- string -- The customer id interested in
                        estimate
                    product_id -- string -- Id of the requested product

        Returns:
            TimeEstimateCollection: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Validate required parameters
        if options.get("start_latitude") == None:
            raise ValueError("Required parameter 'start_latitude' cannot be None.")
        elif options.get("start_longitude") == None:
            raise ValueError("Required parameter 'start_longitude' cannot be None.")

        # The base uri for api requests
        _query_builder = Configuration.BASE_URI
 
        # Prepare query string for API call
        _query_builder += "/v1/estimates/time"

        # Process optional query parameters
        _query_parameters = {
            "start_latitude": options.get('start_latitude', None),
            "start_longitude": options.get('start_longitude', None),
            "customer_uuid": options.get('customer_uuid', None),
            "product_id": options.get('product_id', None)
        }
        
        # Validate and preprocess url
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            "user-agent": "APIMATIC 2.0",
            "accept": "application/json",
            "Authorization": "Bearer " + Configuration.o_auth_access_token
        }

        # Prepare the API call.
        _http_request = self.http_client.get(_query_url, headers=_headers, query_parameters=_query_parameters)

        # Invoke the on before request HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_before_request(_http_request)

        # Invoke the API call  to fetch the response.
        _response = self.http_client.execute_as_string(_http_request)

        # Invoke the on after response HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_after_response(_response)

        # Endpoint error handling using HTTP status codes.
        if _response.status_code == 404:
            return None
        elif _response.status_code == 400:
            raise APIException("Malformed request.", 400, _response.raw_body)
        elif _response.status_code == 401:
            raise APIException("Unauthorized the request requires user authentication (not logged in).", 401, _response.raw_body)
        elif _response.status_code == 403:
            raise APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", 403, _response.raw_body)
        elif _response.status_code == 406:
            raise APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", 406, _response.raw_body)
        elif _response.status_code == 422:
            raise APIException("Invalid request. The request body is parse-able however with invalid content.", 422, _response.raw_body)
        elif _response.status_code == 429:
            raise APIException("Too Many Requests. Rate limited.", 429, _response.raw_body)
        elif _response.status_code == 500:
            raise APIException("Internal Server Error.", 500, _response.raw_body)

        # Global error handling using HTTP status codes.
        self.validate_response(_response)    

        # Return appropriate type
        return APIHelper.json_deserialize(_response.raw_body, TimeEstimateCollection.from_dictionary)



    def get_user_activity_v_1_1(self,
                                options=dict()):
        """Does a GET request to /v1.1/history.

        The User Activity endpoint returns data about a user's lifetime
        activity with Uber. The response will include pickup locations and
        times, dropoff locations and times, the distance of past requests, and
        information about which products were requested.

        Args:
            options (dict, optional): Key-value pairs for any of the
                parameters to this API Endpoint. All parameters to the
                endpoint are supplied through the dictionary with their names
                being the key and their desired values being the value. A list
                of parameters that can be used are::

                    limit -- int -- Number of items to return for pagging
                    offset -- int -- Page offset for pagging

        Returns:
            UserActivity: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Validate required parameters
        if options.get("limit") == None:
            raise ValueError("Required parameter 'limit' cannot be None.")
        elif options.get("offset") == None:
            raise ValueError("Required parameter 'offset' cannot be None.")

        # The base uri for api requests
        _query_builder = Configuration.BASE_URI
 
        # Prepare query string for API call
        _query_builder += "/v1.1/history"

        # Process optional query parameters
        _query_parameters = {
            "limit": options.get('limit', None),
            "offset": options.get('offset', None)
        }
        
        # Validate and preprocess url
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            "user-agent": "APIMATIC 2.0",
            "accept": "application/json",
            "Authorization": "Bearer " + Configuration.o_auth_access_token
        }

        # Prepare the API call.
        _http_request = self.http_client.get(_query_url, headers=_headers, query_parameters=_query_parameters)

        # Invoke the on before request HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_before_request(_http_request)

        # Invoke the API call  to fetch the response.
        _response = self.http_client.execute_as_string(_http_request)

        # Invoke the on after response HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_after_response(_response)

        # Endpoint error handling using HTTP status codes.
        if _response.status_code == 404:
            return None
        elif _response.status_code == 400:
            raise APIException("Malformed request.", 400, _response.raw_body)
        elif _response.status_code == 401:
            raise APIException("Unauthorized the request requires user authentication (not logged in).", 401, _response.raw_body)
        elif _response.status_code == 403:
            raise APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", 403, _response.raw_body)
        elif _response.status_code == 406:
            raise APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", 406, _response.raw_body)
        elif _response.status_code == 422:
            raise APIException("Invalid request. The request body is parse-able however with invalid content.", 422, _response.raw_body)
        elif _response.status_code == 429:
            raise APIException("Too Many Requests. Rate limited.", 429, _response.raw_body)
        elif _response.status_code == 500:
            raise APIException("Internal Server Error.", 500, _response.raw_body)

        # Global error handling using HTTP status codes.
        self.validate_response(_response)    

        # Return appropriate type
        return APIHelper.json_deserialize(_response.raw_body, UserActivity.from_dictionary)



    def get_user_profile(self):
        """Does a GET request to /v1/me.

        The User Profile endpoint returns information about the Uber user that
        has authorized with the application.

        Returns:
            UserProfile: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # The base uri for api requests
        _query_builder = Configuration.BASE_URI
 
        # Prepare query string for API call
        _query_builder += "/v1/me"
        
        # Validate and preprocess url
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            "user-agent": "APIMATIC 2.0",
            "accept": "application/json",
            "Authorization": "Bearer " + Configuration.o_auth_access_token
        }

        # Prepare the API call.
        _http_request = self.http_client.get(_query_url, headers=_headers)

        # Invoke the on before request HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_before_request(_http_request)

        # Invoke the API call  to fetch the response.
        _response = self.http_client.execute_as_string(_http_request)

        # Invoke the on after response HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_after_response(_response)

        # Endpoint error handling using HTTP status codes.
        if _response.status_code == 404:
            return None
        elif _response.status_code == 400:
            raise APIException("Malformed request.", 400, _response.raw_body)
        elif _response.status_code == 401:
            raise APIException("Unauthorized the request requires user authentication (not logged in).", 401, _response.raw_body)
        elif _response.status_code == 403:
            raise APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", 403, _response.raw_body)
        elif _response.status_code == 406:
            raise APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.", 406, _response.raw_body)
        elif _response.status_code == 422:
            raise APIException("Invalid request. The request body is parse-able however with invalid content.", 422, _response.raw_body)
        elif _response.status_code == 429:
            raise APIException("Too Many Requests. Rate limited.", 429, _response.raw_body)
        elif _response.status_code == 500:
            raise APIException("Internal Server Error.", 500, _response.raw_body)

        # Global error handling using HTTP status codes.
        self.validate_response(_response)    

        # Return appropriate type
        return APIHelper.json_deserialize(_response.raw_body, UserProfile.from_dictionary)



    def get_product_detail_by_id(self,
                                 product_id):
        """Does a GET request to /v1/products/{product_id}.

        Get product details w.r.t id

        Args:
            product_id (string): Unique identifier representing a specific
                product for a given latitude & longitude. For example, uberX
                in San Francisco will have a different product_id than uberX
                in Los Angeles.

        Returns:
            Product: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Validate required parameters
        if product_id == None:
            raise ValueError("Required parameter 'product_id' cannot be None.")

        # The base uri for api requests
        _query_builder = Configuration.BASE_URI
 
        # Prepare query string for API call
        _query_builder += "/v1/products/{product_id}"

        # Process optional template parameters
        _query_builder = APIHelper.append_url_with_template_parameters(_query_builder, { 
            "product_id": product_id
        })
        
        # Validate and preprocess url
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            "user-agent": "APIMATIC 2.0",
            "accept": "application/json",
            "Authorization": "Bearer " + Configuration.o_auth_access_token
        }

        # Prepare the API call.
        _http_request = self.http_client.get(_query_url, headers=_headers)

        # Invoke the on before request HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_before_request(_http_request)

        # Invoke the API call  to fetch the response.
        _response = self.http_client.execute_as_string(_http_request)

        # Invoke the on after response HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_after_response(_response)

        # Endpoint error handling using HTTP status codes.
        if _response.status_code == 404:
            return None

        # Global error handling using HTTP status codes.
        self.validate_response(_response)    

        # Return appropriate type
        return APIHelper.json_deserialize(_response.raw_body, Product.from_dictionary)



    def get_promotions(self,
                       options=dict()):
        """Does a GET request to /v1/promotions.

        The Promotions endpoint returns information about the promotion that
        will be available to a new user based on their activity's location.
        These promotions do not apply for existing users.

        Args:
            options (dict, optional): Key-value pairs for any of the
                parameters to this API Endpoint. All parameters to the
                endpoint are supplied through the dictionary with their names
                being the key and their desired values being the value. A list
                of parameters that can be used are::

                    end_latitude -- float -- Latitude component of end
                        location.
                    end_longitude -- float -- Longitude component of end
                        location.
                    start_latitude -- float -- Latitude component of start
                        location.
                    start_longitude -- float -- Longitude component of start
                        location

        Returns:
            PromotionsResponse: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Validate required parameters
        if options.get("end_latitude") == None:
            raise ValueError("Required parameter 'end_latitude' cannot be None.")
        elif options.get("end_longitude") == None:
            raise ValueError("Required parameter 'end_longitude' cannot be None.")
        elif options.get("start_latitude") == None:
            raise ValueError("Required parameter 'start_latitude' cannot be None.")
        elif options.get("start_longitude") == None:
            raise ValueError("Required parameter 'start_longitude' cannot be None.")

        # The base uri for api requests
        _query_builder = Configuration.BASE_URI
 
        # Prepare query string for API call
        _query_builder += "/v1/promotions"

        # Process optional query parameters
        _query_parameters = {
            "end_latitude": options.get('end_latitude', None),
            "end_longitude": options.get('end_longitude', None),
            "start_latitude": options.get('start_latitude', None),
            "start_longitude": options.get('start_longitude', None)
        }
        
        # Validate and preprocess url
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            "user-agent": "APIMATIC 2.0",
            "accept": "application/json",
            "Authorization": "Bearer " + Configuration.o_auth_access_token
        }

        # Prepare the API call.
        _http_request = self.http_client.get(_query_url, headers=_headers, query_parameters=_query_parameters)

        # Invoke the on before request HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_before_request(_http_request)

        # Invoke the API call  to fetch the response.
        _response = self.http_client.execute_as_string(_http_request)

        # Invoke the on after response HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_after_response(_response)

        # Endpoint error handling using HTTP status codes.
        if _response.status_code == 404:
            return None
        elif _response.status_code == 400:
            raise APIException("Malformed request.", 400, _response.raw_body)
        elif _response.status_code == 401:
            raise APIException("Unauthorized the request requires user authentication (not logged in).", 401, _response.raw_body)
        elif _response.status_code == 403:
            raise APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", 403, _response.raw_body)
        elif _response.status_code == 406:
            raise APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", 406, _response.raw_body)
        elif _response.status_code == 409:
            raise APIException("A conflict needs to be resolved before the request can be made.", 409, _response.raw_body)
        elif _response.status_code == 422:
            raise APIException("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", 422, _response.raw_body)
        elif _response.status_code == 429:
            raise APIException("Too Many Requests. Rate limited", 429, _response.raw_body)
        elif _response.status_code == 500:
            raise APIException("Internal Server Error.", 500, _response.raw_body)
        elif _response.status_code == 222:
            raise APIException("bac", 222, _response.raw_body)

        # Global error handling using HTTP status codes.
        self.validate_response(_response)    

        # Return appropriate type
        return APIHelper.json_deserialize(_response.raw_body, PromotionsResponse.from_dictionary)



    def create_request(self,
                       body):
        """Does a POST request to /v1/requests.

        The Request endpoint allows a ride to be requested on behalf of an
        Uber user given their desired product, start, and end locations.
        Please review the Sandbox documentation on how to develop and test
        against these endpoints without making real-world Requests and being
        charged.

        Args:
            body (RequestBody): TODO: type description here. Example: 

        Returns:
            Request: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Validate required parameters
        if body == None:
            raise ValueError("Required parameter 'body' cannot be None.")

        # The base uri for api requests
        _query_builder = Configuration.BASE_URI
 
        # Prepare query string for API call
        _query_builder += "/v1/requests"
        
        # Validate and preprocess url
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            "user-agent": "APIMATIC 2.0",
            "accept": "application/json",
            "content-type": "application/json; charset=utf-8",
            "Authorization": "Bearer " + Configuration.o_auth_access_token
        }

        # Prepare the API call.
        _http_request = self.http_client.post(_query_url, headers=_headers, parameters=APIHelper.json_serialize(body))

        # Invoke the on before request HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_before_request(_http_request)

        # Invoke the API call  to fetch the response.
        _response = self.http_client.execute_as_string(_http_request)

        # Invoke the on after response HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_after_response(_response)

        # Endpoint error handling using HTTP status codes.
        if _response.status_code == 404:
            return None
        elif _response.status_code == 400:
            raise APIException("Malformed request", 400, _response.raw_body)
        elif _response.status_code == 401:
            raise APIException("Unauthorized the request requires user authentication (not logged in).", 401, _response.raw_body)
        elif _response.status_code == 403:
            raise APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", 403, _response.raw_body)
        elif _response.status_code == 406:
            raise APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json", 406, _response.raw_body)
        elif _response.status_code == 409:
            raise APIException("A conflict needs to be resolved before the request can be made.", 409, _response.raw_body)
        elif _response.status_code == 422:
            raise APIException("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", 422, _response.raw_body)
        elif _response.status_code == 429:
            raise APIException("Too Many Requests. Rate limited.", 429, _response.raw_body)
        elif _response.status_code == 500:
            raise APIException("Internal Server Error.", 500, _response.raw_body)

        # Global error handling using HTTP status codes.
        self.validate_response(_response)    

        # Return appropriate type
        return APIHelper.json_deserialize(_response.raw_body, Request.from_dictionary)



    def get_request_details(self,
                            request_id):
        """Does a GET request to /v1/requests/{request_id}.

        Get the real time status of an ongoing trip that was created using the
        Ride Request endpoint.

        Args:
            request_id (string): TODO: type description here. Example: 

        Returns:
            RequestDetailsCollections: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Validate required parameters
        if request_id == None:
            raise ValueError("Required parameter 'request_id' cannot be None.")

        # The base uri for api requests
        _query_builder = Configuration.BASE_URI
 
        # Prepare query string for API call
        _query_builder += "/v1/requests/{request_id}"

        # Process optional template parameters
        _query_builder = APIHelper.append_url_with_template_parameters(_query_builder, { 
            "request_id": request_id
        })
        
        # Validate and preprocess url
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            "user-agent": "APIMATIC 2.0",
            "accept": "application/json",
            "Authorization": "Bearer " + Configuration.o_auth_access_token
        }

        # Prepare the API call.
        _http_request = self.http_client.get(_query_url, headers=_headers)

        # Invoke the on before request HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_before_request(_http_request)

        # Invoke the API call  to fetch the response.
        _response = self.http_client.execute_as_string(_http_request)

        # Invoke the on after response HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_after_response(_response)

        # Endpoint error handling using HTTP status codes.
        if _response.status_code == 404:
            return None
        elif _response.status_code == 400:
            raise APIException("Malformed request.", 400, _response.raw_body)
        elif _response.status_code == 401:
            raise APIException("Unauthorized the request requires user authentication (not logged in).", 401, _response.raw_body)
        elif _response.status_code == 403:
            raise APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", 403, _response.raw_body)
        elif _response.status_code == 406:
            raise APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", 406, _response.raw_body)
        elif _response.status_code == 409:
            raise APIException("A conflict needs to be resolved before the request can be made.", 409, _response.raw_body)
        elif _response.status_code == 422:
            raise APIException("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", 422, _response.raw_body)
        elif _response.status_code == 429:
            raise APIException("Too Many Requests. Rate limited.", 429, _response.raw_body)
        elif _response.status_code == 500:
            raise APIException("Internal Server Error", 500, _response.raw_body)

        # Global error handling using HTTP status codes.
        self.validate_response(_response)    

        # Return appropriate type
        return APIHelper.json_deserialize(_response.raw_body, RequestDetailsCollections.from_dictionary)



    def delete_request_cancel(self,
                              request_id):
        """Does a DELETE request to /v1/requests/{request_id}.

        Cancel an ongoing Request on behalf of a rider.

        Args:
            request_id (string): Unique identifier representing a Request.

        Returns:
            void: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Validate required parameters
        if request_id == None:
            raise ValueError("Required parameter 'request_id' cannot be None.")

        # The base uri for api requests
        _query_builder = Configuration.BASE_URI
 
        # Prepare query string for API call
        _query_builder += "/v1/requests/{request_id}"

        # Process optional template parameters
        _query_builder = APIHelper.append_url_with_template_parameters(_query_builder, { 
            "request_id": request_id
        })
        
        # Validate and preprocess url
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            "user-agent": "APIMATIC 2.0",
            "Authorization": "Bearer " + Configuration.o_auth_access_token
        }

        # Prepare the API call.
        _http_request = self.http_client.delete(_query_url, headers=_headers)

        # Invoke the on before request HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_before_request(_http_request)

        # Invoke the API call  to fetch the response.
        _response = self.http_client.execute_as_string(_http_request)

        # Invoke the on after response HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_after_response(_response)

        # Endpoint error handling using HTTP status codes.
        if _response.status_code == 400:
            raise APIException("Malformed request.", 400, _response.raw_body)
        elif _response.status_code == 401:
            raise APIException("Unauthorized the request requires user authentication (not logged in).", 401, _response.raw_body)
        elif _response.status_code == 403:
            raise APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.", 403, _response.raw_body)
        elif _response.status_code == 406:
            raise APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", 406, _response.raw_body)
        elif _response.status_code == 409:
            raise APIException("A conflict needs to be resolved before the request can be made", 409, _response.raw_body)
        elif _response.status_code == 422:
            raise APIException("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", 422, _response.raw_body)
        elif _response.status_code == 429:
            raise APIException("Too Many Requests. Rate limited.", 429, _response.raw_body)
        elif _response.status_code == 500:
            raise APIException("Internal Server Error", 500, _response.raw_body)

        # Global error handling using HTTP status codes.
        self.validate_response(_response)    

    def get_request_map(self,
                        request_id):
        """Does a GET request to /v1/requests/{request_id}/map.

        Get a map with a visual representation of a Request.

        Args:
            request_id (string): Unique identifier representing a Request.

        Returns:
            RequestMapResponse: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Validate required parameters
        if request_id == None:
            raise ValueError("Required parameter 'request_id' cannot be None.")

        # The base uri for api requests
        _query_builder = Configuration.BASE_URI
 
        # Prepare query string for API call
        _query_builder += "/v1/requests/{request_id}/map"

        # Process optional template parameters
        _query_builder = APIHelper.append_url_with_template_parameters(_query_builder, { 
            "request_id": request_id
        })
        
        # Validate and preprocess url
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            "user-agent": "APIMATIC 2.0",
            "accept": "application/json",
            "Authorization": "Bearer " + Configuration.o_auth_access_token
        }

        # Prepare the API call.
        _http_request = self.http_client.get(_query_url, headers=_headers)

        # Invoke the on before request HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_before_request(_http_request)

        # Invoke the API call  to fetch the response.
        _response = self.http_client.execute_as_string(_http_request)

        # Invoke the on after response HttpCallBack if specified
        if self.http_call_back != None:
            self.http_call_back.on_after_response(_response)

        # Endpoint error handling using HTTP status codes.
        if _response.status_code == 404:
            return None
        elif _response.status_code == 400:
            raise APIException("Malformed request.", 400, _response.raw_body)
        elif _response.status_code == 401:
            raise APIException("Unauthorized the request requires user authentication (not logged in).", 401, _response.raw_body)
        elif _response.status_code == 403:
            raise APIException("Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues", 403, _response.raw_body)
        elif _response.status_code == 406:
            raise APIException("Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.", 406, _response.raw_body)
        elif _response.status_code == 409:
            raise APIException("A conflict needs to be resolved before the request can be made.", 409, _response.raw_body)
        elif _response.status_code == 422:
            raise APIException("Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.", 422, _response.raw_body)
        elif _response.status_code == 429:
            raise APIException("Too Many Requests. Rate limited.", 429, _response.raw_body)
        elif _response.status_code == 500:
            raise APIException("Internal Server Error.", 500, _response.raw_body)

        # Global error handling using HTTP status codes.
        self.validate_response(_response)    

        # Return appropriate type
        return APIHelper.json_deserialize(_response.raw_body, RequestMapResponse.from_dictionary)


